<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Dashboard with Constellation Background</title>
  <style>
    /* Reset + base */
    * { box-sizing: border-box; }
    html, body { height: 100%; margin: 0; background: #1f1f23; }

    /* Constellation background canvas */
    #constellation {
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      display: block;
      z-index: -1;           /* behind all content */
      filter: blur(2.5px);   /* soft blur */
      opacity: 0.9;          /* subtle, not overpowering */
      pointer-events: none;  /* don’t block clicks */
      background: #1f1f23;   /* solid grey bg */
    }

    /* Example dashboard card (replace with your own content) */
    .content {
      position: relative;
      display: grid;
      place-items: center;
      min-height: 100vh;
      color: #f6f7f9;
      font: 700 1.25rem/1.5 system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      text-shadow: 0 2px 6px rgba(0,0,0,.35);
      z-index: 1;
    }
    .card {
      background: rgba(0,0,0,0.25);
      border: 1px solid rgba(255,255,255,.08);
      border-radius: 16px;
      padding: 28px 32px;
      backdrop-filter: saturate(130%) blur(8px);
      box-shadow: 0 10px 40px rgba(0,0,0,.35);
      max-width: 640px;
      text-align: center;
    }
    .card h1 { margin: 0 0 8px; font-size: 2rem; }
    .card p { margin: 0; opacity: .9; }
  </style>
</head>
<body>
  <!-- Background -->
  <canvas id="constellation" aria-hidden="true"></canvas>

  <!-- Your dashboard / content -->
  <main class="content">
    <div class="card">
      <h1>My Dashboard</h1>
      <p>All of your existing UI goes here, the background stays behind ✨</p>
    </div>
  </main>

  <!-- Background script -->
  <script>
  (() => {
    const cfg = {
      particleCount: 120,
      maxConnections: 6,
      linkDistance: 140,
      linkWidth: 1.0,
      particleSize: [1.2, 2.2],
      speed: [0.2, 0.7],
      cursorRadius: 160,
      background: "#1f1f23", // grey
      dotColor: "#ffffff",   // white dots
      lineColor: "#ffffff",  // white lines
      lineAlpha: 0.55,
      densityBase: 1920*1080
    };

    const cvs = document.getElementById('constellation');
    const ctx = cvs.getContext('2d', { alpha: false });
    const DPR = Math.max(1, Math.min(window.devicePixelRatio || 1, 2));
    let particles = [];
    const mouse = { x: null, y: null, active: false };
    let running = true;

    function rand(min, max){ return Math.random() * (max - min) + min; }

    function resize(){
      const w = window.innerWidth, h = window.innerHeight;
      cvs.style.width = w + 'px';
      cvs.style.height = h + 'px';
      cvs.width = Math.floor(w * DPR);
      cvs.height = Math.floor(h * DPR);
      ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
      ctx.fillStyle = cfg.background;
      ctx.fillRect(0, 0, w, h);
      const scale = Math.max(0.4, Math.min(2.0, (w*h) / cfg.densityBase));
      setParticleCount(Math.round(cfg.particleCount * scale));
    }

    class P {
      constructor(w,h){ this.reset(w,h,true); }
      reset(w,h,pos=false){
        this.x = pos ? Math.random()*w : this.x;
        this.y = pos ? Math.random()*h : this.y;
        this.vx = rand(cfg.speed[0], cfg.speed[1]) * (Math.random()<.5?-1:1);
        this.vy = rand(cfg.speed[0], cfg.speed[1]) * (Math.random()<.5?-1:1);
        this.r = rand(cfg.particleSize[0], cfg.particleSize[1]);
        this.connections = 0;
      }
      step(w,h){
        if (mouse.active){
          const dx = mouse.x - this.x, dy = mouse.y - this.y;
          const r = cfg.cursorRadius, d2 = dx*dx + dy*dy;
          if (d2 < r*r){
            const f = (1 - Math.sqrt(d2)/r) * 0.02;
            this.vx += dx * f; this.vy += dy * f;
          }
        }
        this.x += this.vx; this.y += this.vy;
        if (this.x < -50) this.x = w + 50;
        if (this.x > w + 50) this.x = -50;
        if (this.y < -50) this.y = h + 50;
        if (this.y > h + 50) this.y = -50;
        this.vx *= 0.995; this.vy *= 0.995;
        this.connections = 0;
      }
      draw(){
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.r, 0, Math.PI*2);
        ctx.fillStyle = cfg.dotColor;
        ctx.fill();
      }
    }

    function setParticleCount(target){
      const w = cvs.clientWidth, h = cvs.clientHeight;
      if (particles.length < target){
        for (let i = particles.length; i < target; i++) particles.push(new P(w,h));
      } else if (particles.length > target){
        particles.length = target;
      }
    }

    function connect(){
      const n = particles.length, maxD = cfg.linkDistance, maxD2 = maxD*maxD;
      ctx.lineWidth = cfg.linkWidth;
      ctx.strokeStyle = cfg.lineColor;
      ctx.globalAlpha = cfg.lineAlpha;
      for (let i=0;i<n;i++){
        const p = particles[i];
        if (p.connections >= cfg.maxConnections) continue;
        for (let j=i+1;j<n;j++){
          const q = particles[j];
          if (q.connections >= cfg.maxConnections) continue;
          const dx = p.x - q.x, dy = p.y - q.y, d2 = dx*dx + dy*dy;
          if (d2 <= maxD2){
            ctx.beginPath();
            ctx.moveTo(p.x, p.y);
            ctx.lineTo(q.x, q.y);
            ctx.stroke();
            p.connections++; q.connections++;
            if (p.connections >= cfg.maxConnections) break;
          }
        }
      }
      ctx.globalAlpha = 1;
    }

    function frame(){
      if (!running) return;
      const w = cvs.clientWidth, h = cvs.clientHeight;
      ctx.fillStyle = cfg.background;
      ctx.fillRect(0, 0, w, h);
      for (const p of particles){ p.step(w,h); p.draw(); }
      connect();
      requestAnimationFrame(frame);
    }

    // Events
    window.addEventListener('resize', resize);
    window.addEventListener('mousemove', e => { mouse.x=e.clientX; mouse.y=e.clientY; mouse.active=true; });
    window.addEventListener('mouseleave', () => { mouse.active=false; });
    window.addEventListener('touchmove', e => {
      const t = e.touches[0]; if (!t) return;
      mouse.x=t.clientX; mouse.y=t.clientY; mouse.active=true;
    }, { passive:true });
    window.addEventListener('touchend', () => { mouse.active=false; });
    document.addEventListener('visibilitychange', () => {
      running = document.visibilityState !== 'hidden';
      if (running) requestAnimationFrame(frame);
    });

    // Init
    resize();
    requestAnimationFrame(frame);
  })();
  </script>
</body>
</html>
